#!/usr/bin/env -S deno run --allow-env

import { parseArgs } from "@std/cli";
import { readAll } from "@std/io";
import { parse } from "node-html-parser";

const VALID_OUTPUTS = ["stdout", "html", "json", "csv", "text"];

/** Parses the HTML input from either a file or stdin.
 * @param {Object} args - The command line arguments.
 * @returns {Promise<HTMLElement>} The parsed HTML root element.
 */
const parseHTML = async (args) => {
  if (typeof args.html === "string" && args.html.trim().length > 0) {
    const root = parse(args.html);
    return root;
  }

  const buffer = await readAll(Deno.stdin);
  const input = new TextDecoder().decode(buffer).trim();

  if (!input) {
    console.error("Error: No data provided via --data or stdin.");
    Deno.exit(1);
  }

  const root = parse(input);
  return root;
};

/**
 * Displays the help message for the chart command.
 * @returns {void}
 */
const showHelp = () =>
  console.log(`
Usage: scrape [options]
Options:
    -h, --help          Show this help message
    -a, --attribute     Specify the attribute to scrape.
    -b, --body          Specify the body element to scrape.
    -e, --selector      Specify the selector to use for scraping.
    -f, --file          Specify the file to scrape.
    -x, --existance     Specify the existance check.
    -r, --raw_input     Specify the raw input to scrape.
    -o, --output        Specify the output file (default: stdout).
  `);

const options = {
  boolean: ["help"],
  string: [
    "attribute",
    "body",
    "selector",
    "file",
    "existance",
    "raw_input",
  ],
  alias: {
    h: "help",
    a: "attribute",
    b: "body",
    e: "selector",
    f: "file",
    x: "existance",
    r: "raw_input",
    o: "output",
  },
};

/**
 * Main function to parse arguments and render the chart.
 * @returns {void}
 */
const main = async () => {
  const args = parseArgs(Deno.args, options);

  if (args.help) {
    showHelp();
    Deno.exit(0);
  }

  if (!args.selector?.length) {
    console.error("Error: --selector is a required option.");
    Deno.exit(1);
  }

  const root = await parseHTML(args);
  const elements = root.removeWhitespace().querySelectorAll(args.selector);

  if (args.attribute) {
    const results = elements
      .map((el) => ({
        [args.attribute]: el.getAttribute(args.attribute),
        textContent: el.textContent.trim(),
      }))
      .filter(Boolean);
    console.table(results);
  }
};

if (import.meta.main) {
  main();
}
