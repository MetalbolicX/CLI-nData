#!/usr/bin/env bash
# ~/bin/dseq

# dseq: Generate a sequence of dates relative to a start day.
#
# Usage:
#   dseq [OPTIONS] LAST
#   dseq [OPTIONS] FIRST LAST
#   dseq [OPTIONS] FIRST INCREMENT LAST
#
# Arguments (positional, after options):
#   LAST        : Generates dates from FIRST (default 0 for today) up to LAST.
#                 If only LAST is given, it implies FIRST=1 and INCREMENT=1.
#   FIRST       : The starting offset in days from the base date.
#   INCREMENT   : The step size in days for the sequence.
#
# Options:
#   -f, --format <format_string>  Specify the output date format (e.g., "%Y-%m-%d", "%A, %B %d, %Y").
#                                 Uses 'date' command format codes. Default: +%F (YYYY-MM-DD).
#   -s, --start-date <date_string>  Specify the base date to start from (e.g., "2023-01-01", "tomorrow", "yesterday").
#                                 Default: today. This affects the '0 day' offset.
#   -h, --help                    Display this help message and exit.
#
# Examples:
#   dseq 1                       # Tomorrow (default: start=today, first=1, inc=1, last=1)
#   dseq 0 0                     # Today (start=today, first=0, last=0)
#   dseq 7                       # Next 7 days (start=today, first=1, inc=1, last=7)
#   dseq -2 0                    # Day before yesterday till today (start=today, first=-2, inc=1, last=0)
#   dseq 1 7 365                 # Tomorrow and then every week for a year (start=today, first=1, inc=7, last=365)
#   dseq -f "%Y/%m/%d %a" 0 2    # Today, tomorrow, day after tomorrow in YYYY/MM/DD Day format
#   dseq -s "2024-12-25" 0 2     # Dec 25, 26, 27 2024
#   dseq -s "last friday" -1 0   # Last Friday and Saturday
#
# Author: Jeroen Janssens (modified by José Martínez Santana)

# --- Configuration ---
DEFAULT_FORMAT="+%F" # YYYY-MM-DD

# --- Variables ---
OUTPUT_FORMAT="$DEFAULT_FORMAT"
START_DATE_MODIFIER="" # Modifier for `date` command

# --- Functions ---

# Function to display usage information
usage() {
    # Print the comments block from the script itself
    grep -E "^#|^#   " "$0" | sed -e 's/^#//g' -e 's/^   //g' | head -n -1
    exit 1
}

# --- Main Script Logic ---

# Parse command-line options
# Using 'getopts' for simpler options or 'getopt' for long options
# For simplicity with 'getopts', we'll only support short options for now.
# Or use 'getopt' for full long option support which is more complex.
# For this script, given the complexity of the positional args,
# a custom while loop for options is often clearer.

ARGS=()
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -f|--format)
            if [[ -n "$2" ]]; then
                OUTPUT_FORMAT="$2"
                shift # consume argument value
            else
                echo "Error: Option '$1' requires an argument." >&2
                usage
            fi
            ;;
        -s|--start-date)
            if [[ -n "$2" ]]; then
                START_DATE_MODIFIER="$2"
                shift # consume argument value
            else
                echo "Error: Option '$1' requires an argument." >&2
                usage
            fi
            ;;
        -h|--help)
            usage
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            usage
            ;;
        *)
            # Positional arguments
            ARGS+=("$1")
            ;;
    esac
    shift # consume argument name or option
done

# Check number of positional arguments after options are parsed
case "${#ARGS[@]}" in
    1) # LAST
        FIRST=1
        INCREMENT=1
        LAST="${ARGS[0]}"
        ;;
    2) # FIRST LAST
        FIRST="${ARGS[0]}"
        INCREMENT=1
        LAST="${ARGS[1]}"
        ;;
    3) # FIRST INCREMENT LAST
        FIRST="${ARGS[0]}"
        INCREMENT="${ARGS[1]}"
        LAST="${ARGS[2]}"
        ;;
    *)
        echo "Error: Invalid number of arguments. See usage." >&2
        usage
        ;;
esac

# Validate arguments are integers
for arg in "$FIRST" "$INCREMENT" "$LAST"; do
    if ! [[ "$arg" =~ ^-?[0-9]+$ ]]; then
        echo "Error: All positional arguments (FIRST, INCREMENT, LAST) must be integers." >&2
        usage
    fi
done

# Ensure INCREMENT is not zero to prevent infinite loop
if (( INCREMENT == 0 )); then
    echo "Error: INCREMENT cannot be zero." >&2
    usage
fi

# Prepare the date base command
# If START_DATE_MODIFIER is set, add it to the date command to set the base day.
DATE_BASE_CMD="date"
if [[ -n "$START_DATE_MODIFIER" ]]; then
    DATE_BASE_CMD+=" --date=\"$START_DATE_MODIFIER\""
fi

# Generate the sequence of day offsets and pipe to date
# Use 'printf' for the format string with `date --file -`
# 'seq' handles the sequence generation
# The 'day' suffix is crucial for 'date --file -' to interpret correctly.
# The 'eval' is used to correctly interpret the DATE_BASE_CMD
# to set the starting date for 'date --file -'.
# We need a temporary file or a process substitution to pipe the 'date' output to 'date --file -'.

# Create a temporary file for the date offsets
TEMP_FILE=$(mktemp)
# Trap to ensure the temporary file is deleted on exit
trap 'rm -f "$TEMP_FILE"' EXIT

# Generate the offsets and write to the temporary file
seq -s $'\n' "$FIRST" "$INCREMENT" "$LAST" | while IFS= read -r offset; do
    echo "$offset day"
done > "$TEMP_FILE"

# Execute the date command using the temporary file
# `eval` is used to allow `DATE_BASE_CMD` to be dynamically built with arguments (like --date).
# Then `date --file -` processes the temporary file.
# Finally, apply the desired output format.
eval "$DATE_BASE_CMD --file=\"$TEMP_FILE\" \"$OUTPUT_FORMAT\""
